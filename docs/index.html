<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Message Channel Tracker · Chrome 확장</title>
    <meta name="description" content="브라우저의 메시지 흐름(window.postMessage, MessageChannel, BroadcastChannel, Worker 등)을 콘솔에 예쁘게 시각화하는 Chrome 확장." />
    <link rel="canonical" href="https://message-channel-tracker.vreality.dev/" />
    <meta property="og:title" content="Message Channel Tracker" />
    <meta property="og:description" content="브라우저의 메시지 흐름을 깨뜨리지 않고 관찰하세요." />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://message-channel-tracker.vreality.dev/" />
    <meta property="og:image" content="https://message-channel-tracker.vreality.dev/assets/og.svg" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Message Channel Tracker" />
    <meta name="twitter:description" content="브라우저의 메시지 흐름을 깨뜨리지 않고 관찰하세요." />
    <meta name="twitter:image" content="https://message-channel-tracker.vreality.dev/assets/og.svg" />
    <meta name="theme-color" content="#0ea5e9" />
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%230ea5e9'/%3E%3Cpath d='M14 24h36M14 32h28M14 40h20' stroke='white' stroke-width='4' stroke-linecap='round'/%3E%3C/svg%3E" />
    <link rel="stylesheet" href="./styles.css" />
  </head>
  <body>
    <header class="site-header container">
      <a class="brand" href="#">
        <span class="logo" aria-hidden="true">MCT</span>
        <span class="brand-text">Message Channel Tracker</span>
      </a>
      <nav class="nav" id="site-nav">
        <a href="#features">기능</a>
        <a href="#install">설치</a>
        <a href="#usage">사용법</a>
        <a href="#how-it-works">동작 원리</a>
        <a href="#faq">FAQ</a>
        <a class="github" href="https://github.com/vreality64/message-channel-tracker" target="_blank" rel="noopener">GitHub</a>
      </nav>
      <div class="header-actions">
        <button class="theme-toggle" id="theme-toggle" aria-label="테마 전환" title="테마 전환">🌓</button>
        <button class="nav-toggle" id="nav-toggle" aria-label="메뉴 열기" title="메뉴">☰</button>
      </div>
    </header>

    <main>
      <section class="hero container reveal">
        <div class="hero-inner">
          <span class="kicker">Chrome 확장</span>
          <h1>
            메시지 채널을 <span class="gradient-text">깨뜨리지 않고</span>
            관찰하세요
          </h1>
          <p class="lead">
            window.postMessage · MessageChannel · BroadcastChannel · Worker/ServiceWorker의 메시지를
            <strong>색상과 그룹</strong>으로 정리해 DevTools 콘솔에서 한눈에.
          </p>
          <div class="badges">
            <span class="badge">비침투적</span>
            <span class="badge">토글 가능</span>
            <span class="badge">읽기 전용</span>
          </div>
          <div class="cta">
            <a class="button primary" href="#install">빠르게 설치하기</a>
            <a class="button" href="https://github.com/vreality64/message-channel-tracker" target="_blank" rel="noopener">GitHub 보기</a>
          </div>
        </div>
        <figure class="hero-visual">
          <picture>
            <source srcset="./assets/hero.webp" type="image/webp" />
            <source srcset="./assets/hero.gif" type="image/gif" />
            <img src="./assets/screenshot.svg" alt="DevTools 콘솔에서 메시지가 색상/그룹으로 정리되어 흐름을 보여주는 장면" width="960" height="540" loading="eager" />
          </picture>
          <figcaption class="visually-hidden">콘솔에 window.postMessage, MessageChannel, BroadcastChannel, Worker 메시지가 스레드처럼 그룹되어 출력되는 모습을 보여줍니다.</figcaption>
        </figure>
      </section>

      <section id="features" class="section container reveal">
        <h2>왜 MCT인가요?</h2>
        <ul class="feature-grid">
          <li class="card">
            <div class="card-title">채널 전반 관측</div>
            <p class="card-desc">window.postMessage, MessageChannel/MessagePort, BroadcastChannel, Worker/SharedWorker, ServiceWorker까지 한번에.</p>
          </li>
          <li class="card">
            <div class="card-title">콘솔에 최적화</div>
            <p class="card-desc">색상/그룹으로 스레드처럼 묶어서 흐름을 따라가기 쉽습니다.</p>
          </li>
          <li class="card">
            <div class="card-title">안전한 읽기 전용</div>
            <p class="card-desc">원래 동작을 바꾸지 않는 비침투적 래핑으로 신뢰도 높음.</p>
          </li>
          <li class="card">
            <div class="card-title">상태 토글</div>
            <p class="card-desc">팝업에서 On/Off, 전역 상태는 <code>chrome.storage.sync</code>에 보존됩니다.</p>
          </li>
        </ul>
      </section>

      <section id="install" class="section container reveal">
        <h2>빠른 시작</h2>
        <ol class="steps">
          <li>주소창에 <code>chrome://extensions</code> 입력</li>
          <li><strong>Developer mode</strong> 활성화</li>
          <li><strong>Load unpacked</strong> → 저장소의 <code>extension/</code> 선택</li>
          <li>확장 아이콘을 고정하고 On/Off로 로깅 제어</li>
        </ol>
        <p class="note">웹스토어 배포 전까지는 수동 로드로 사용하세요.</p>
      </section>

      <section id="usage" class="section container reveal">
        <h2>사용법</h2>
        <div class="usage-grid">
          <div>
            <p>아무 페이지의 DevTools 콘솔에서 실행해 보세요. 콘솔에 MCT 로그가 출력됩니다.</p>
            <div class="code-block">
              <button class="copy-btn" data-copy="#demo-code">복사</button>
              <pre class="code"><code id="demo-code">window.postMessage("hello from MCT", "*");</code></pre>
            </div>
            <p class="small">여러 채널을 한 번에 시험하려면 로컬 <strong>Playground</strong>를 사용하세요. <code>pnpm run docs</code>로
              정적 서버를 띄운 뒤 <code>/playground/</code>에 접속.</p>
          </div>
          <figure class="usage-visual">
            <img src="./assets/screenshot.svg" alt="MCT 콘솔 미리보기" width="640" height="360" loading="lazy" />
          </figure>
        </div>
      </section>

      <section id="how-it-works" class="section container reveal">
        <h2>동작 원리</h2>
        <div class="split">
          <div>
            <ul>
              <li><code>content.js</code>가 <code>pageHook.js</code>를 삽입해 페이지 컨텍스트에서 안전하게 내장 객체를 래핑합니다.</li>
              <li>메시지는 색상/그룹으로 정리되어 콘솔에 출력됩니다.</li>
              <li>토글 이벤트(<code>MCT:SET_ENABLED</code>)로 로깅을 제어합니다.</li>
              <li>원래 동작을 바꾸지 않는 <em>읽기 전용</em> 설계입니다.</li>
            </ul>
            <p class="small">필요 권한: <code>storage</code>, <code>tabs</code></p>
          </div>
          <div class="callout">
            <div class="callout-title">주의</div>
            <p>대량 메시지 환경에서는 성능을 위해 필요 시에만 On으로 전환하거나, 콘솔 필터링을 함께 사용하세요.</p>
          </div>
        </div>
      </section>

      <section id="faq" class="section container reveal">
        <h2>FAQ</h2>
        <details>
          <summary>성능에 영향이 있나요?</summary>
          <p>일반적인 개발/디버깅 시나리오에서 영향을 최소화하도록 구현했습니다. 대량 메시지 환경에서는 토글을 Off하여 부하를 줄일 수 있습니다.</p>
        </details>
        <details>
          <summary>프로덕션 페이지에 사용해도 되나요?</summary>
          <p>개발/테스트 용도로 권장됩니다. 프로덕션 환경에서는 필요 시점에만 On으로 전환하세요.</p>
        </details>
        <details>
          <summary>무엇을 로깅하나요?</summary>
          <p>window.postMessage, MessageChannel/MessagePort, BroadcastChannel, Worker/SharedWorker, ServiceWorker의 postMessage/수신 메시지 이벤트를 다룹니다.</p>
        </details>
      </section>
    </main>

    <footer class="site-footer container">
      <p>© <span id="year"></span> Message Channel Tracker · <a href="https://github.com/vreality64/message-channel-tracker" target="_blank" rel="noopener">GitHub</a></p>
    </footer>
    <script>
      // Copyright year
      document.getElementById('year').textContent = new Date().getFullYear();

      // Reveal on scroll
      const observer = new IntersectionObserver((entries) => {
        for (const entry of entries) {
          if (entry.isIntersecting) {
            entry.target.classList.add('is-visible');
            observer.unobserve(entry.target);
          }
        }
      }, { threshold: 0.12 });
      document.querySelectorAll('.reveal').forEach(el => observer.observe(el));

      // Theme toggle with localStorage preference
      const root = document.documentElement;
      const themeToggle = document.getElementById('theme-toggle');
      const savedTheme = localStorage.getItem('mct:theme');
      if (savedTheme === 'light' || savedTheme === 'dark') {
        root.setAttribute('data-theme', savedTheme);
      }
      themeToggle?.addEventListener('click', () => {
        const next = root.getAttribute('data-theme') === 'light' ? 'dark' : 'light';
        root.setAttribute('data-theme', next);
        localStorage.setItem('mct:theme', next);
      });

      // Mobile nav toggle
      const nav = document.getElementById('site-nav');
      const navToggle = document.getElementById('nav-toggle');
      navToggle?.addEventListener('click', () => {
        nav?.classList.toggle('open');
      });

      // Copy to clipboard for code block
      document.addEventListener('click', (e) => {
        const target = e.target;
        if (target && target.matches('.copy-btn')) {
          const selector = target.getAttribute('data-copy');
          const code = selector ? document.querySelector(selector)?.textContent : '';
          if (code) {
            navigator.clipboard.writeText(code).then(() => {
              const prev = target.textContent;
              target.textContent = '복사됨!';
              setTimeout(() => target.textContent = prev, 1200);
            });
          }
        }
      });
    </script>
  </body>
</html>
